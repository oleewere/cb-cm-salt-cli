/*
 * Cloudera Manager API
 *
 * <h1>Cloudera Manager API v32</h1>       <p>Introduced in Cloudera Manager 6.2.0</p>       <p><a href=\"http://www.cloudera.com/documentation.html\">Cloudera Product Documentation</a></p>
 *
 * API version: 6.2.0
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package cm-client

import (
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"context"
	"fmt"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type EventsResourceApiService service

/* 
EventsResourceApiService Returns a specific event in the system.
Returns a specific event in the system
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param eventId The UUID of the event to read

@return ApiEvent
*/
func (a *EventsResourceApiService) ReadEvent(ctx context.Context, eventId string) (ApiEvent, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ApiEvent
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/events/{eventId}"
	localVarPath = strings.Replace(localVarPath, "{"+"eventId"+"}", fmt.Sprintf("%v", eventId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
			if err != nil {
				return localVarReturnValue, localVarHttpResponse, err
			}

			var v ApiEvent
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
EventsResourceApiService Allows you to query events in the system.
Allows you to query events in the system.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ReadEventsOpts - Optional Parameters:
     * @param "MaxResults" (optional.Int32) -  The maximum number of events to return.
     * @param "Query" (optional.String) -  The query to perform to find events in the system. It accepts querying the intersection of a list of constraints, joined together with semicolons (without spaces). For example: &lt;/p&gt; &lt;dl&gt; &lt;dt&gt;alert&#x3D;&#x3D;true&lt;/dt&gt; &lt;dd&gt;looks for alerts.&lt;/dd&gt; &lt;dt&gt;alert&#x3D;&#x3D;true;attributes.host!&#x3D;flaky.mysite.com&lt;/dt&gt; &lt;dd&gt;looks for alerts, but exclude those with the host attribute of \&quot;flaky.mysite.com\&quot;.&lt;/dd&gt; &lt;dt&gt;category&#x3D;&#x3D;log_event;attributes.log_level&#x3D;&#x3D;ERROR&lt;/dt&gt; &lt;dd&gt;looks for error log events. Event attribute matching is case sensitive.&lt;/dd&gt; &lt;dt&gt;attributes.service&#x3D;&#x3D;hbase1;content&#x3D;&#x3D;hlog&lt;/dt&gt; &lt;dd&gt;looks for any events from the \&quot;hbase1\&quot; service that mention \&quot;hlog\&quot;.&lt;/dd&gt; &lt;dt&gt;attributes.service&#x3D;&#x3D;hbase1;content!&#x3D;hlog&lt;/dt&gt; &lt;dd&gt;looks for any events from the \&quot;hbase1\&quot; service that do not mention \&quot;hlog\&quot;.&lt;br/&gt; A query must not contain only negative constraints (&lt;em&gt;!&#x3D;&lt;/em&gt;). It returns empty results because there is nothing to perform exclusion on.&lt;/dd&gt; &lt;dt&gt;attributes.role_type&#x3D;&#x3D;NAMENODE;severity&#x3D;&#x3D;critical important&lt;/dt&gt; &lt;dd&gt;looks for any important or critical events related to all NameNodes.&lt;/dd&gt; &lt;dt&gt;severity&#x3D;&#x3D;critical;timeReceived&#x3D;ge&#x3D;2012-05-04T00:00;timeReceived&#x3D;lt&#x3D;2012-05-04T00:10&lt;/dt&gt; &lt;dd&gt;looks for critical events received between the given 10 minute range. &lt;br/&gt; When polling for events, use &lt;em&gt;timeReceived&lt;/em&gt; instead of &lt;em&gt;timeOccurred&lt;/em&gt; because events arrive out of order.&lt;/dd&gt; &lt;/dl&gt;  You may query any fields present in the ApiEvent object. You can also query by event attribute values using the &lt;em&gt;attributes.*&lt;/em&gt; syntax. Values for date time fields (e.g. &lt;em&gt;timeOccurred&lt;/em&gt;, &lt;em&gt;timeReceived&lt;/em&gt;) should be ISO8601 timestamps. &lt;p&gt; The other valid comparators are &lt;em&gt;&#x3D;lt&#x3D;&lt;/em&gt;, &lt;em&gt;&#x3D;le&#x3D;&lt;/em&gt;, &lt;em&gt;&#x3D;ge&#x3D;&lt;/em&gt;, and &lt;em&gt;&#x3D;gt&#x3D;&lt;/em&gt;. They stand for \&quot;&amp;lt;\&quot;, \&quot;&amp;lt;&#x3D;\&quot;, \&quot;&amp;gt;&#x3D;\&quot;, \&quot;&amp;gt;\&quot; respectively. These comparators are only applicable for date time fields.
     * @param "ResultOffset" (optional.Int32) -  Specified the offset of events to return.

@return ApiEventQueryResult
*/

type ReadEventsOpts struct { 
	MaxResults optional.Int32
	Query optional.String
	ResultOffset optional.Int32
}

func (a *EventsResourceApiService) ReadEvents(ctx context.Context, localVarOptionals *ReadEventsOpts) (ApiEventQueryResult, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ApiEventQueryResult
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/events"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.MaxResults.IsSet() {
		localVarQueryParams.Add("maxResults", parameterToString(localVarOptionals.MaxResults.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Query.IsSet() {
		localVarQueryParams.Add("query", parameterToString(localVarOptionals.Query.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ResultOffset.IsSet() {
		localVarQueryParams.Add("resultOffset", parameterToString(localVarOptionals.ResultOffset.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
			if err != nil {
				return localVarReturnValue, localVarHttpResponse, err
			}

			var v ApiEventQueryResult
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
