/*
 * Cloudera Manager API
 *
 * <h1>Cloudera Manager API v32</h1>       <p>Introduced in Cloudera Manager 6.2.0</p>       <p><a href=\"http://www.cloudera.com/documentation.html\">Cloudera Product Documentation</a></p>
 *
 * API version: 6.2.0
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package cmapi

import (
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"context"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type AuditsResourceApiService service

/* 
AuditsResourceApiService Fetch audit events from Cloudera Manager (CM) and CM managed services like HDFS, HBase, Impala, Hive, and Sentry.
Fetch audit events from Cloudera Manager (CM) and CM managed services like HDFS, HBase, Impala, Hive, and Sentry. &lt;p&gt; By default, this call will fetch the first 100 audit events (sorted from most recent to oldest) corresponding to a 1 day window based on provided end time (which defaults to the  current CM server time). The &lt;em&gt;startTime&lt;/em&gt; and &lt;em&gt;endTime&lt;/em&gt; parameters can be used to control the window being queried. &lt;p&gt; Audit events for CM managed services are only retrieved if Cloudera Navigator server is running.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *ReadAuditsOpts - Optional Parameters:
     * @param "EndTime" (optional.String) -  End of the period to query in ISO 8601 format (defaults to current time).
     * @param "MaxResults" (optional.Int32) -  Maximum number of audits to return
     * @param "Query" (optional.String) -  The query to filter out audits in the system. It accepts querying the intersection of a list of constraints, joined together with semicolons (without spaces). For example: &lt;/p&gt; &lt;dl&gt; &lt;dt&gt;command&#x3D;&#x3D;listStatus&lt;/dt&gt; &lt;dd&gt;looks for audits with listStatus command.&lt;/dd&gt; &lt;dt&gt;command&#x3D;&#x3D;listStatus;username!&#x3D;foo&lt;/dt&gt; &lt;dd&gt;looks for audits with listStatus command but excludes audits generated by foo username&lt;/dd&gt; &lt;dt&gt;command&#x3D;&#x3D;listStatus;source&#x3D;&#x3D;*oozie*&lt;/dt&gt; &lt;dd&gt;looks for audits with listStatus command and source that contains the string &#39;oozie&#39;. &lt;/dd&gt; &lt;/dl&gt;  Following are valid selectors for the query (if applicable to the audit): &lt;table&gt; &lt;tr&gt; &lt;th&gt; Selector &lt;/th&gt; &lt;th&gt; Description &lt;/th&gt; &lt;th&gt; SCM &lt;/th&gt; &lt;th&gt; HDFS &lt;/th&gt; &lt;th&gt; HBase &lt;/th&gt; &lt;th&gt; Hive &lt;/th&gt; &lt;th&gt; Impala &lt;/th&gt; &lt;th&gt; Sentry &lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; service &lt;/td&gt; &lt;td&gt; Cloudera Manager Service &lt;/td&gt; &lt;td&gt; x &lt;/td&gt; &lt;td&gt; x &lt;/td&gt; &lt;td&gt; x &lt;/td&gt; &lt;td&gt; x &lt;/td&gt; &lt;td&gt; x &lt;/td&gt; &lt;td&gt; x &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; operation &lt;/td&gt; &lt;td&gt; Operation name &lt;/td&gt; &lt;td&gt; x &lt;/td&gt; &lt;td&gt; x &lt;/td&gt; &lt;td&gt; x &lt;/td&gt; &lt;td&gt; x &lt;/td&gt; &lt;td&gt; x &lt;/td&gt; &lt;td&gt; x &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; username &lt;/td&gt; &lt;td&gt; User name &lt;/td&gt; &lt;td&gt; x &lt;/td&gt; &lt;td&gt; x &lt;/td&gt; &lt;td&gt; x &lt;/td&gt; &lt;td&gt; x &lt;/td&gt; &lt;td&gt; x &lt;/td&gt; &lt;td&gt; x &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; impersonator&lt;/td&gt; &lt;td&gt; Impersonator &lt;/td&gt; &lt;td&gt; &lt;/td&gt; &lt;td&gt; x &lt;/td&gt; &lt;td&gt; x &lt;/td&gt; &lt;td&gt; x &lt;/td&gt; &lt;td&gt; x &lt;/td&gt; &lt;td&gt; x &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; ip_address &lt;/td&gt; &lt;td&gt; IP Address &lt;/td&gt; &lt;td&gt; x &lt;/td&gt; &lt;td&gt; x &lt;/td&gt; &lt;td&gt; x &lt;/td&gt; &lt;td&gt; x &lt;/td&gt; &lt;td&gt; x &lt;/td&gt; &lt;td&gt; x &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; allowed &lt;/td&gt; &lt;td&gt; Whether the request was allowed or denied &lt;/td&gt; &lt;td&gt; x &lt;/td&gt; &lt;td&gt; x &lt;/td&gt; &lt;td&gt; x &lt;/td&gt; &lt;td&gt; x &lt;/td&gt; &lt;td&gt; x &lt;/td&gt; &lt;td&gt; x &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; qualifier&lt;/td&gt; &lt;td&gt; Column qualifier &lt;/td&gt; &lt;td&gt; &lt;/td&gt; &lt;td&gt; &lt;/td&gt; &lt;td&gt; x &lt;/td&gt; &lt;td&gt; &lt;/td&gt; &lt;td&gt; &lt;/td&gt; &lt;td&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; source &lt;/td&gt; &lt;td&gt; Source resource of the operation  &lt;/td&gt; &lt;td&gt; x &lt;/td&gt; &lt;td&gt; x &lt;/td&gt; &lt;td&gt; x &lt;/td&gt; &lt;td&gt; x &lt;/td&gt; &lt;td&gt; x &lt;/td&gt; &lt;td&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; destination &lt;/td&gt; &lt;td&gt; Destination resource of the operation &lt;/td&gt; &lt;td&gt; &lt;/td&gt; &lt;td&gt; x &lt;/td&gt; &lt;td&gt; x &lt;/td&gt; &lt;td&gt; x &lt;/td&gt; &lt;td&gt; x &lt;/td&gt; &lt;td&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; hostIpAddress &lt;/td&gt; &lt;td&gt; Host IP Address &lt;/td&gt; &lt;td&gt; x &lt;/td&gt; &lt;td&gt; &lt;/td&gt; &lt;td&gt; &lt;/td&gt; &lt;td&gt; &lt;/td&gt; &lt;td&gt; &lt;/td&gt; &lt;td&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; role &lt;/td&gt; &lt;td&gt; Cloudera Manager Role &lt;/td&gt; &lt;td&gt; x &lt;/td&gt; &lt;td&gt; &lt;/td&gt; &lt;td&gt; &lt;/td&gt; &lt;td&gt; &lt;/td&gt; &lt;td&gt; &lt;/td&gt; &lt;td&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; family &lt;/td&gt; &lt;td&gt; Column family &lt;/td&gt; &lt;td&gt; &lt;/td&gt; &lt;td&gt; &lt;/td&gt; &lt;td&gt; x &lt;/td&gt; &lt;td&gt; &lt;/td&gt; &lt;td&gt; &lt;/td&gt; &lt;td&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; database_name &lt;/td&gt; &lt;td&gt; Database name &lt;/td&gt; &lt;td&gt; &lt;/td&gt; &lt;td&gt; &lt;/td&gt; &lt;td&gt; &lt;/td&gt; &lt;td&gt; x &lt;/td&gt; &lt;td&gt; x &lt;/td&gt; &lt;td&gt; x &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; table_name &lt;/td&gt; &lt;td&gt; Table name &lt;/td&gt; &lt;td&gt; &lt;/td&gt; &lt;td&gt; &lt;/td&gt; &lt;td&gt; x &lt;/td&gt; &lt;td&gt; x &lt;/td&gt; &lt;td&gt; x &lt;/td&gt; &lt;td&gt; x &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; object_type &lt;/td&gt; &lt;td&gt; Type of object being handled &lt;/td&gt; &lt;td&gt; &lt;/td&gt; &lt;td&gt; &lt;/td&gt; &lt;td&gt; &lt;/td&gt; &lt;td&gt; x &lt;/td&gt; &lt;td&gt; x &lt;/td&gt; &lt;td&gt; x &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt; operation_text &lt;/td&gt; &lt;td&gt; Command/query text &lt;/td&gt; &lt;td&gt; &lt;/td&gt; &lt;td&gt; &lt;/td&gt; &lt;td&gt; &lt;/td&gt; &lt;td&gt; x &lt;/td&gt; &lt;td&gt; x &lt;/td&gt; &lt;td&gt; x &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;p&gt; The only supported operator is &lt;em&gt;\&quot;;\&quot;&lt;/em&gt; (Boolean AND). Boolean OR is not supported. &lt;p&gt; The supported comparators are &lt;em&gt;&#x3D;&#x3D;&lt;/em&gt; and &lt;em&gt;!&#x3D;&lt;/em&gt; Note that \&quot;LIKE\&quot; comparison is supported using the wild card syntax, for example &lt;em&gt;foo&#x3D;&#x3D;*value*&lt;/em&gt;. Asterisk is interpreted as a wild card character and must not be part of the value. (LIKE comparison queries are converted to standard SQL LIKE syntax, so any % (%25) character in a value that also contains a wild card will be interpreted as a wild card.) &lt;p/&gt; Available since API v8. A subset of these features is available since v4.
     * @param "ResultOffset" (optional.Int32) -  Offset of audits to return
     * @param "StartTime" (optional.String) -  Start of the period to query in ISO 8601 format (defaults to 1 day ago relative to endTime).

@return ApiAuditList
*/

type ReadAuditsOpts struct { 
	EndTime optional.String
	MaxResults optional.Int32
	Query optional.String
	ResultOffset optional.Int32
	StartTime optional.String
}

func (a *AuditsResourceApiService) ReadAudits(ctx context.Context, localVarOptionals *ReadAuditsOpts) (ApiAuditList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ApiAuditList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/audits"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.EndTime.IsSet() {
		localVarQueryParams.Add("endTime", parameterToString(localVarOptionals.EndTime.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MaxResults.IsSet() {
		localVarQueryParams.Add("maxResults", parameterToString(localVarOptionals.MaxResults.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Query.IsSet() {
		localVarQueryParams.Add("query", parameterToString(localVarOptionals.Query.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ResultOffset.IsSet() {
		localVarQueryParams.Add("resultOffset", parameterToString(localVarOptionals.ResultOffset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StartTime.IsSet() {
		localVarQueryParams.Add("startTime", parameterToString(localVarOptionals.StartTime.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
			if err != nil {
				return localVarReturnValue, localVarHttpResponse, err
			}

			var v ApiAuditList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
AuditsResourceApiService

 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param optional nil or *StreamAuditsOpts - Optional Parameters:
     * @param "EndTime" (optional.String) -  
     * @param "MaxResults" (optional.Int32) -  
     * @param "Query" (optional.String) -  
     * @param "ResultOffset" (optional.Int32) -  
     * @param "StartTime" (optional.String) -  

@return *os.File
*/

type StreamAuditsOpts struct { 
	EndTime optional.String
	MaxResults optional.Int32
	Query optional.String
	ResultOffset optional.Int32
	StartTime optional.String
}

func (a *AuditsResourceApiService) StreamAudits(ctx context.Context, localVarOptionals *StreamAuditsOpts) (*os.File, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue *os.File
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/audits/stream"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.EndTime.IsSet() {
		localVarQueryParams.Add("endTime", parameterToString(localVarOptionals.EndTime.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.MaxResults.IsSet() {
		localVarQueryParams.Add("maxResults", parameterToString(localVarOptionals.MaxResults.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Query.IsSet() {
		localVarQueryParams.Add("query", parameterToString(localVarOptionals.Query.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ResultOffset.IsSet() {
		localVarQueryParams.Add("resultOffset", parameterToString(localVarOptionals.ResultOffset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.StartTime.IsSet() {
		localVarQueryParams.Add("startTime", parameterToString(localVarOptionals.StartTime.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
			if err != nil {
				return localVarReturnValue, localVarHttpResponse, err
			}

			var v *os.File
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
