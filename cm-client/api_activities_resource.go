/*
 * Cloudera Manager API
 *
 * <h1>Cloudera Manager API v32</h1>       <p>Introduced in Cloudera Manager 6.2.0</p>       <p><a href=\"http://www.cloudera.com/documentation.html\">Cloudera Product Documentation</a></p>
 *
 * API version: 6.2.0
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */

package cm-client

import (
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
	"context"
	"fmt"
	"github.com/antihax/optional"
)

// Linger please
var (
	_ context.Context
)

type ActivitiesResourceApiService service

/* 
ActivitiesResourceApiService Fetch metric readings for a particular activity.
Fetch metric readings for a particular activity. &lt;p&gt; By default, this call will look up all metrics available for the activity. If only specific metrics are desired, use the &lt;i&gt;metrics&lt;/i&gt; parameter. &lt;p&gt; By default, the returned results correspond to a 5 minute window based on the provided end time (which defaults to the current server time). The &lt;i&gt;from&lt;/i&gt; and &lt;i&gt;to&lt;/i&gt; parameters can be used to control the window being queried. A maximum window of 3 hours is enforced. &lt;p&gt; When requesting a \&quot;full\&quot; view, aside from the extended properties of the returned metric data, the collection will also contain information about all metrics available for the activity, even if no readings are available in the requested window.
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param activityId The name of the activity.
 * @param clusterName The name of the cluster.
 * @param serviceName The name of the service.
 * @param optional nil or *GetMetricsOpts - Optional Parameters:
     * @param "From" (optional.String) -  Start of the period to query.
     * @param "Metrics" (optional.Interface of []string) -  Filter for which metrics to query.
     * @param "To" (optional.String) -  End of the period to query.
     * @param "View" (optional.String) -  The view of the data to materialize, either \&quot;summary\&quot; or \&quot;full\&quot;.

@return ApiMetricList
*/

type GetMetricsOpts struct { 
	From optional.String
	Metrics optional.Interface
	To optional.String
	View optional.String
}

func (a *ActivitiesResourceApiService) GetMetrics(ctx context.Context, activityId string, clusterName string, serviceName string, localVarOptionals *GetMetricsOpts) (ApiMetricList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ApiMetricList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/clusters/{clusterName}/services/{serviceName}/activities/{activityId}/metrics"
	localVarPath = strings.Replace(localVarPath, "{"+"activityId"+"}", fmt.Sprintf("%v", activityId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"clusterName"+"}", fmt.Sprintf("%v", clusterName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"serviceName"+"}", fmt.Sprintf("%v", serviceName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.From.IsSet() {
		localVarQueryParams.Add("from", parameterToString(localVarOptionals.From.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Metrics.IsSet() {
		localVarQueryParams.Add("metrics", parameterToString(localVarOptionals.Metrics.Value(), "multi"))
	}
	if localVarOptionals != nil && localVarOptionals.To.IsSet() {
		localVarQueryParams.Add("to", parameterToString(localVarOptionals.To.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.View.IsSet() {
		localVarQueryParams.Add("view", parameterToString(localVarOptionals.View.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
			if err != nil {
				return localVarReturnValue, localVarHttpResponse, err
			}

			var v ApiMetricList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ActivitiesResourceApiService Read all activities in the system.
Read all activities in the system
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param clusterName The name of the cluster
 * @param serviceName The name of the service
 * @param optional nil or *ReadActivitiesOpts - Optional Parameters:
     * @param "MaxResults" (optional.Int32) -  The maximum number of activities to return.
     * @param "Query" (optional.String) -  The query to perform to find activities in the system. By default, this call returns top level (i.e. root) activities that have currently started. &lt;p&gt; The query specifies the intersection of a list of constraints, joined together with semicolons (without spaces). For example: &lt;/p&gt; &lt;dl&gt; &lt;dt&gt;status&#x3D;&#x3D;started;parent&#x3D;&#x3D;&lt;/dt&gt; &lt;dd&gt;looks for running root activities. This is also the default query.&lt;/dd&gt; &lt;dt&gt;status&#x3D;&#x3D;failed;finishTime&#x3D;gt&#x3D;2012-04-01T20:30:00.000Z&lt;/dt&gt; &lt;dd&gt;looks for failed activities after the given date time.&lt;/dd&gt; &lt;dt&gt;name&#x3D;&#x3D;Pi Estimator;startTime&#x3D;gt&#x3D;2012-04-01T20:30:00.000Z&lt;/dt&gt; &lt;dd&gt;looks for activities started after the given date time, with the name of \&quot;Pi Estimator\&quot;.&lt;/dd&gt; &lt;dt&gt;startTime&#x3D;lt&#x3D;2012-01-02T00:00:00.000Z;finishTime&#x3D;ge&#x3D;2012-01-01T00:00:00.000Z&lt;/dt&gt; &lt;dd&gt;looks for activities that are active on 2012 New Year&#39;s Day. Note that they may start before or finish after that day.&lt;/dd&gt; &lt;dt&gt;status&#x3D;&#x3D;failed;parent&#x3D;&#x3D;000014-20120425161321-oozie-joe&lt;/dt&gt; &lt;dd&gt;looks for failed child activities of the given parent activity id.&lt;/dd&gt; &lt;dt&gt;status&#x3D;&#x3D;started;metrics.cpu_user&#x3D;gt&#x3D;10&lt;/dt&gt; &lt;dd&gt;looks for started activities that are using more than 10 cores per second.&lt;/dd&gt; &lt;dt&gt;type&#x3D;&#x3D;hive;metrics.user&#x3D;&#x3D;bc;finishTime&#x3D;gt&#x3D;2012-04-01T20:30:00.000Z&lt;/dt&gt; &lt;dd&gt;looks for all hive queries submitted by user bc after the given date time.&lt;/dd&gt; &lt;/dl&gt;  You may query any fields present in the ApiActivity object. You can also query by activity metric values using the &lt;em&gt;metrics.*&lt;/em&gt; syntax. Values for date time fields should be ISO8601 timestamps. &lt;p&gt; The valid comparators are &lt;em&gt;&#x3D;&#x3D;&lt;/em&gt;, &lt;em&gt;!&#x3D;&lt;/em&gt;, &lt;em&gt;&#x3D;lt&#x3D;&lt;/em&gt;, &lt;em&gt;&#x3D;le&#x3D;&lt;/em&gt;, &lt;em&gt;&#x3D;ge&#x3D;&lt;/em&gt;, and &lt;em&gt;&#x3D;gt&#x3D;&lt;/em&gt;. They stand for \&quot;&#x3D;&#x3D;\&quot;, \&quot;!&#x3D;\&quot;, \&quot;&amp;lt;\&quot;, \&quot;&amp;lt;&#x3D;\&quot;, \&quot;&amp;gt;&#x3D;\&quot;, \&quot;&amp;gt;\&quot; respectively.
     * @param "ResultOffset" (optional.Int32) -  Specified the offset of activities to return.
     * @param "View" (optional.String) -  The view of the activities to materialize

@return ApiActivityList
*/

type ReadActivitiesOpts struct { 
	MaxResults optional.Int32
	Query optional.String
	ResultOffset optional.Int32
	View optional.String
}

func (a *ActivitiesResourceApiService) ReadActivities(ctx context.Context, clusterName string, serviceName string, localVarOptionals *ReadActivitiesOpts) (ApiActivityList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ApiActivityList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/clusters/{clusterName}/services/{serviceName}/activities"
	localVarPath = strings.Replace(localVarPath, "{"+"clusterName"+"}", fmt.Sprintf("%v", clusterName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"serviceName"+"}", fmt.Sprintf("%v", serviceName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.MaxResults.IsSet() {
		localVarQueryParams.Add("maxResults", parameterToString(localVarOptionals.MaxResults.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.Query.IsSet() {
		localVarQueryParams.Add("query", parameterToString(localVarOptionals.Query.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ResultOffset.IsSet() {
		localVarQueryParams.Add("resultOffset", parameterToString(localVarOptionals.ResultOffset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.View.IsSet() {
		localVarQueryParams.Add("view", parameterToString(localVarOptionals.View.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
			if err != nil {
				return localVarReturnValue, localVarHttpResponse, err
			}

			var v ApiActivityList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ActivitiesResourceApiService Returns a specific activity in the system.
Returns a specific activity in the system
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param activityId The id of the activity to retrieve
 * @param clusterName The name of the cluster
 * @param serviceName The name of the service
 * @param optional nil or *ReadActivityOpts - Optional Parameters:
     * @param "View" (optional.String) -  The view of the activity to materialize

@return ApiActivity
*/

type ReadActivityOpts struct { 
	View optional.String
}

func (a *ActivitiesResourceApiService) ReadActivity(ctx context.Context, activityId string, clusterName string, serviceName string, localVarOptionals *ReadActivityOpts) (ApiActivity, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ApiActivity
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/clusters/{clusterName}/services/{serviceName}/activities/{activityId}"
	localVarPath = strings.Replace(localVarPath, "{"+"activityId"+"}", fmt.Sprintf("%v", activityId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"clusterName"+"}", fmt.Sprintf("%v", clusterName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"serviceName"+"}", fmt.Sprintf("%v", serviceName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.View.IsSet() {
		localVarQueryParams.Add("view", parameterToString(localVarOptionals.View.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
			if err != nil {
				return localVarReturnValue, localVarHttpResponse, err
			}

			var v ApiActivity
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ActivitiesResourceApiService Returns the child activities.
Returns the child activities
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param activityId The id of the activity
 * @param clusterName The name of the cluster
 * @param serviceName The name of the service
 * @param optional nil or *ReadChildActivitiesOpts - Optional Parameters:
     * @param "MaxResults" (optional.Int32) -  The maximum number of activities to return.
     * @param "ResultOffset" (optional.Int32) -  Specified the offset of activities to return.
     * @param "View" (optional.String) -  The view of the children to materialize

@return ApiActivityList
*/

type ReadChildActivitiesOpts struct { 
	MaxResults optional.Int32
	ResultOffset optional.Int32
	View optional.String
}

func (a *ActivitiesResourceApiService) ReadChildActivities(ctx context.Context, activityId string, clusterName string, serviceName string, localVarOptionals *ReadChildActivitiesOpts) (ApiActivityList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ApiActivityList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/clusters/{clusterName}/services/{serviceName}/activities/{activityId}/children"
	localVarPath = strings.Replace(localVarPath, "{"+"activityId"+"}", fmt.Sprintf("%v", activityId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"clusterName"+"}", fmt.Sprintf("%v", clusterName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"serviceName"+"}", fmt.Sprintf("%v", serviceName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.MaxResults.IsSet() {
		localVarQueryParams.Add("maxResults", parameterToString(localVarOptionals.MaxResults.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.ResultOffset.IsSet() {
		localVarQueryParams.Add("resultOffset", parameterToString(localVarOptionals.ResultOffset.Value(), ""))
	}
	if localVarOptionals != nil && localVarOptionals.View.IsSet() {
		localVarQueryParams.Add("view", parameterToString(localVarOptionals.View.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
			if err != nil {
				return localVarReturnValue, localVarHttpResponse, err
			}

			var v ApiActivityList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}

/* 
ActivitiesResourceApiService Returns a list of similar activities.
Returns a list of similar activities
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param activityId The id of the activity
 * @param clusterName The name of the cluster
 * @param serviceName The name of the service
 * @param optional nil or *ReadSimilarActivitiesOpts - Optional Parameters:
     * @param "View" (optional.String) -  The view of the activities to materialize

@return ApiActivityList
*/

type ReadSimilarActivitiesOpts struct { 
	View optional.String
}

func (a *ActivitiesResourceApiService) ReadSimilarActivities(ctx context.Context, activityId string, clusterName string, serviceName string, localVarOptionals *ReadSimilarActivitiesOpts) (ApiActivityList, *http.Response, error) {
	var (
		localVarHttpMethod = strings.ToUpper("Get")
		localVarPostBody   interface{}
		localVarFileName   string
		localVarFileBytes  []byte
		localVarReturnValue ApiActivityList
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath + "/clusters/{clusterName}/services/{serviceName}/activities/{activityId}/similar"
	localVarPath = strings.Replace(localVarPath, "{"+"activityId"+"}", fmt.Sprintf("%v", activityId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"clusterName"+"}", fmt.Sprintf("%v", clusterName), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"serviceName"+"}", fmt.Sprintf("%v", serviceName), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if localVarOptionals != nil && localVarOptionals.View.IsSet() {
		localVarQueryParams.Add("view", parameterToString(localVarOptionals.View.Value(), ""))
	}
	// to determine the Content-Type header
	localVarHttpContentTypes := []string{}

	// set Content-Type header
	localVarHttpContentType := selectHeaderContentType(localVarHttpContentTypes)
	if localVarHttpContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHttpContentType
	}

	// to determine the Accept header
	localVarHttpHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHttpHeaderAccept := selectHeaderAccept(localVarHttpHeaderAccepts)
	if localVarHttpHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHttpHeaderAccept
	}
	r, err := a.client.prepareRequest(ctx, localVarPath, localVarHttpMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHttpResponse, err := a.client.callAPI(r)
	if err != nil || localVarHttpResponse == nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
	localVarHttpResponse.Body.Close()
	if err != nil {
		return localVarReturnValue, localVarHttpResponse, err
	}

	if localVarHttpResponse.StatusCode < 300 {
		// If we succeed, return the data, otherwise pass on to decode error.
		err = a.client.decode(&localVarReturnValue, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
		if err == nil { 
			return localVarReturnValue, localVarHttpResponse, err
		}
	}

	if localVarHttpResponse.StatusCode >= 300 {
		newErr := GenericSwaggerError{
			body: localVarBody,
			error: localVarHttpResponse.Status,
		}
		
		if localVarHttpResponse.StatusCode == 200 {
			localVarBody, err := ioutil.ReadAll(localVarHttpResponse.Body)
			if err != nil {
				return localVarReturnValue, localVarHttpResponse, err
			}

			var v ApiActivityList
			err = a.client.decode(&v, localVarBody, localVarHttpResponse.Header.Get("Content-Type"));
				if err != nil {
					newErr.error = err.Error()
					return localVarReturnValue, localVarHttpResponse, newErr
				}
				newErr.model = v
				return localVarReturnValue, localVarHttpResponse, newErr
		}
		
		return localVarReturnValue, localVarHttpResponse, newErr
	}

	return localVarReturnValue, localVarHttpResponse, nil
}
